let external (plus : int -> int -> int) = "(+)"

type 'a list = Nil | Cons of 'a * 'a list

class Functor f { fmap : (int -> int) -> int f -> int f }
class Functor f => Applicative f
  { monoidal_unit : int f }

instance Functor list {
  fmap = fun f -> fun l -> match l with
    | Nil -> Nil
    | Cons (x, xs) -> Cons (f x, fmap f xs)
}

instance Applicative list {
  monoidal_unit = Cons (0, Nil)
}

let x = fmap (fun y -> plus y 1) (Cons (1, Cons (2, Nil)))

let pure = fun x -> fmap (fun y -> x) monoidal_unit

let z = match pure 42 with | Cons (a, Nil) -> a | x -> 0

